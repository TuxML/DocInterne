# Database status
## 1. Introduction

When refactoring the whole core project, we stumble upon the database part,
which provide a data set for Machine Learning algorithm.

The whole database consist in two main tables : *compilations* and
*incremental_compilations*.

**Note** : We will mark Primary Key with **bold** font and will mark Foreign Key
with **_field_name_**(table.field_name_origin).

The two tables tables are divided as follow :

- compilations

| Field |  Type  | Meaning |
| ----- | ------ | ------- |
| **cid** | int(11) | The unique id of each compilation made. It stands for *c*ompilation *id*. Note that each compilation are unique, but the result can be redundant.        |
| compilation_date | datetime | When the compilation have been made. |
| compilation_time | float | How many time have elapsed during the compilation. If negative, it mainly means that the compilation failed. Time is in seconds. |
| config_file | longblob | The configuration file used to specify the Linux kernel configuration. Present in a compressed form. |
| stdlog_file | longblob | The standard output of the compilation, different from what was display to the user. |
| errlog_file | longblob | The error output of the compilation, different from what was display to the user.
| output_file | longblob | What are display to the user. |
| core_size | int(11) | The size of the compiled kernel. Will be 0 if the compilation failed. Size is in Byte. |
| compressed_size | text | The size of the compiled kernel, depending on the compression algorithm used. Size is in Byte. |
| dependencies | longtext | (?) |
| gcc_version | varchar(32) | Version of the GCC and G++ compiler. |
| libc_version | varchar(32) | Version of the LDD linker. |
| core_used | int(11) | The number of cores used during the compilation. |
| incremental_mod | tinyint(1) | States if this compilation have been made in incremental mode. |
| tuxml_version | varchar(32) | The version of TuxML when doing this compilation. |
| git_branch | varchar(32) | (?) Always blank. |
| docker_image | varchar(32) | (?) Always blank. |
| os | varchar(32) | The system kernel on which we compile. Could be Linux, Windows, MacOS or Java. |
| distribution | varchar(32) | Assuming we are using Linux, the distribution name (e.g. debian, fedora, ...). |
| distrib_version | varchar(32) | Assuming we are using Linux, the distribution version. |
| kernel | varchar(32) | The system kernel version. |
| arch | varchar(32) | The architecture on which we are running the compilation and for which we compile (e.g. x86_x64, arm64, ...). |
| cpu | varchar(128) | The brand name of the cpu which is used for the compilation. |
| cpu_cores | int(11) | The total number of thread available for this CPU. |
| cpu_freq | varchar(32) | A sample of this cpu frequencies. |
| ram | int(11) | The ram size, in kB. |
| mechanical_drive | tinyint(1) | Determine if we are using an HDD or something else. |

- incremental_compilations

| Field |  Type  | Meaning |
| ----- | ------ | ------- |
| **_cid_incmod_**(compilations.cid) | int(11) | The corresponding **cid** of a compilation made with incremental mode. |
| **_cid_origin_**(compilations.cid) | int(11) | The corresponding **cid** of the compilation which resulting object file are reused to compile the **_cid_incmod_**. |

## 2. Problematics

This design present some flaws :

- The database size : for each compilation, we have a record for every field
which isn't size compliant, because the database size can explode easily and
some record are a lot redundant.
- The naming : some field name could be enigmatic, even if we know what we are
working with. Also, they can lead to some ambiguity : for example, the _kernel_
field is about the kernel name, kernel version, the kernel on which we compile,
the kernel that we compile, etc.
- The relevance : some field lack accuracy or are interdependent. For example,
the _cpu\_freq_ field is the actual frequency of the cpu before the compilation.
It will be more useful to know the actual range of frequency for the processor
rather than some value which isn't really relevant with the compilation.
- Extensibility : right now, we are try to include some new field, about 
different version of linux kernel we want to compile, or the boot time and boot
log. But it will need to be added directly to the compilations table, which
already contains a lot of data and will take time to modify.

## 3. Proposition

In order to respond to this flaws, we will propose a division in five different
table.

**Note** : From now on, all fields and tables name will follow Snake case with
no uppercase. (If you don't what is it : <https://en.wikipedia.org/wiki/Snake_case>)

- compilations : From the old compilations table, retains field which is
directly related to the compilation result.

| Field | Type | Explanations |
| ----- | ---- | ------------ |
| **cid** | int(11) | |
| compilation_date | datetime | |
| compilation_time | float | |
| config_file | longblob | |
| stdout_log_file | longblob | Old field _compilations.stdlog\_file_. |
| stderr_log_file | longblob | Old field _compilations.errlog\_file_. |
| user_output_file | longblob | Old field _compilations.output\_file_. |
| compiled_kernel_size | int(11) | Old field _compilations.core\_size_.|
| compressed_compiled_kernel_size | text | Old field _compilations.compressed\_size_. |
| incremental_level | int(3) | Old field _incremental\_mod_. See explanation below for more. |

Why incremental_level? Actually, when we use the incremental mode, we use the
first compilation result as a base for all the other, which is an
incremental_level of one. Therefore, if we want to make a chain of compilation,
it will only add an incremental_level (2+).

// Insert schema :

A -> B

A -> C

A -> D

vs A -> B -> C -> D

- incrementals_compilations_relation
cid *2

- boot

- hardware_environment

- software_environment

- performance //FUTURE